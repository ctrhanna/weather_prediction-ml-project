# -*- coding: utf-8 -*-
"""Weather prediction final.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/106i5xN6HsJceeEPszpuhdy3Mey19qeVf
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder
from sklearn.metrics import accuracy_score, classification_report

from sklearn.ensemble import RandomForestClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.svm import SVC
from sklearn.neighbors import KNeighborsClassifier
import xgboost as xgb

from sklearn.utils import resample

df = pd.read_csv('/content/weather_prediction_dataset.csv')

df_classified = df[['BASEL_temp_mean', 'BASEL_humidity', 'BASEL_cloud_cover',
                    'BASEL_pressure', 'BASEL_precipitation']].copy()

def label_weather(row):
    if row['BASEL_precipitation'] > 0:
        return 'Rainy'
    elif row['BASEL_cloud_cover'] >= 6:
        return 'Cloudy'
    else:
        return 'Sunny'

def classify_temp(temp):
    if temp < 10:
        return "Cold"
    elif 10 <= temp <= 25:
        return "Moderate"
    else:
        return "Hot"

df_classified['WeatherCondition'] = df_classified.apply(label_weather, axis=1)
df_classified['TempRangeClass'] = df_classified['BASEL_temp_mean'].apply(classify_temp)
df_classified['RainLikelihood'] = df_classified['BASEL_precipitation'].apply(lambda x: 'Yes' if x > 0 else 'No')
df_classified['HumidityCloudProduct'] = df_classified['BASEL_humidity'] * df_classified['BASEL_cloud_cover']

print("\n🔍 Original Class Distribution (Before Upsampling):")
print(df_classified['WeatherCondition'].value_counts())

sunny = df_classified[df_classified['WeatherCondition'] == 'Sunny']
rainy = df_classified[df_classified['WeatherCondition'] == 'Rainy']
cloudy = df_classified[df_classified['WeatherCondition'] == 'Cloudy']

max_count = max(len(sunny), len(rainy), len(cloudy))

sunny_upsampled = resample(sunny, replace=True, n_samples=max_count, random_state=42)
rainy_upsampled = resample(rainy, replace=True, n_samples=max_count, random_state=42)
cloudy_upsampled = resample(cloudy, replace=True, n_samples=max_count, random_state=42)

df_balanced = pd.concat([sunny_upsampled, rainy_upsampled, cloudy_upsampled])

print("\nCurrent Dataset Size After Upsampling:")
print(f"Total Number of Samples: {df_balanced.shape[0]}")
print("\nNumber of Samples in Each Class:")
print(df_balanced['WeatherCondition'].value_counts())

features = ['BASEL_temp_mean', 'BASEL_humidity', 'BASEL_cloud_cover',
            'BASEL_pressure', 'HumidityCloudProduct']

X = df_balanced[features]
y = df_balanced['WeatherCondition']

le_weather = LabelEncoder()
y_encoded = le_weather.fit_transform(y)

X_train, X_test, y_train, y_test = train_test_split(
    X, y_encoded, test_size=0.2, random_state=42, stratify=y_encoded)

from sklearn.metrics import accuracy_score, classification_report, confusion_matrix, ConfusionMatrixDisplay

models = {
    'Random Forest': RandomForestClassifier(n_estimators=1000, random_state=42),
    'XGBoost': xgb.XGBClassifier(use_label_encoder=False, eval_metric='mlogloss', random_state=42),
    'Logistic Regression': LogisticRegression(max_iter=500),
    'SVM': SVC(),
    'KNN': KNeighborsClassifier()
}

results = {}

for model_name, model in models.items():
    model.fit(X_train, y_train)
    y_pred = model.predict(X_test)
    acc = accuracy_score(y_test, y_pred)
    results[model_name] = acc * 100
    print(f"\n {model_name} Accuracy: {acc * 100:.2f}%")
    print(f" Classification Report for {model_name}:")
    print(classification_report(y_test, y_pred, target_names=le_weather.classes_))

    # Confusion Matrix
    cm = confusion_matrix(y_test, y_pred)
    disp = ConfusionMatrixDisplay(confusion_matrix=cm, display_labels=le_weather.classes_)
    disp.plot(cmap='Oranges')
    plt.title(f'Confusion Matrix - {model_name}')
    plt.show()

plt.figure(figsize=(8, 5))
sns.barplot(x=list(results.values()), y=list(results.keys()), palette='coolwarm')
plt.title('Model Accuracy Comparison')
plt.xlabel('Accuracy (%)')
plt.ylabel('Models')
plt.xlim(0, 100)
plt.grid(True)
plt.tight_layout()
plt.show()

# 1. Weather Condition Distribution
plt.figure(figsize=(6, 4))
sns.countplot(data=df_balanced, x='WeatherCondition', palette='Set2')
plt.title('Weather Condition Distribution (Balanced)')
plt.xlabel('Condition')
plt.ylabel('Count')
plt.tight_layout()
plt.show()

# 2. Temperature Class Distribution
plt.figure(figsize=(6, 4))
sns.countplot(data=df_balanced, x='TempRangeClass', palette='coolwarm')
plt.title('Temperature Class Distribution (Balanced)')
plt.xlabel('Temperature Class')
plt.ylabel('Count')
plt.tight_layout()
plt.show()

# 3. Correlation Heatmap
plt.figure(figsize=(6, 5))
sns.heatmap(df_balanced[features].corr(), annot=True, cmap='YlGnBu')
plt.title('Feature Correlation Heatmap')
plt.tight_layout()
plt.show()

def full_weather_prediction(model, temp_mean, humidity, cloud_cover, pressure):
    input_data = np.array([[temp_mean, humidity, cloud_cover, pressure, humidity * cloud_cover]])
    weather_class = model.predict(input_data)
    weather_label = le_weather.inverse_transform(weather_class)[0]

    temp_class = classify_temp(temp_mean)
    rain_likelihood = "Yes" if cloud_cover >= 6 or weather_label == "Rainy" else "No"

    print("\n Prediction Summary:")
    print(f"→ Weather Condition: {weather_label}")
    print(f"→ Temperature Class: {temp_class}")
    print(f"→ Rain Likelihood: {rain_likelihood}")

    return {
        "WeatherCondition": weather_label,
        "TemperatureClass": temp_class,
        "RainLikelihood": rain_likelihood
    }

test_samples = [
    {'temp_mean': 12, 'humidity': 90, 'cloud_cover': 8, 'pressure': 1005},
    {'temp_mean': 26, 'humidity': 60, 'cloud_cover': 3, 'pressure': 1012},
    {'temp_mean': 18, 'humidity': 80, 'cloud_cover': 7, 'pressure': 1002},
    {'temp_mean': 30, 'humidity': 40, 'cloud_cover': 2, 'pressure': 1016},
    {'temp_mean': 22, 'humidity': 88, 'cloud_cover': 9, 'pressure': 1000}
]

for idx, sample in enumerate(test_samples, 1):
    print(f"\n Test Sample {idx}:")
    full_weather_prediction(models['XGBoost'], **sample)